/**
 * Injection File Generator
 *
 * Generate injection files for manual assistant updates.
 * Supports both Anthropic direct API and MermAId Chat API.
 */

import { writeFileSync, mkdirSync, existsSync } from "fs";
import { join, dirname } from "path";
import type { InjectionFile, GeneratedPrompt } from "@/lib/types";
import { createLogger } from "@/lib/utils/logger";
import { generateId, hashContent } from "@/lib/utils/validation";
import {
  generateVersionPath,
  generateInjectionFileName,
  generatePromptFileName,
} from "@/lib/utils/version-tracker";

const logger = createLogger("injection-generator");

/**
 * Generate injection file content with MermAId API support
 */
export function generateInjectionContent(params: {
  accountId: string;
  assistantId: string;
  version: string;
  promptContent: string;
  metadata?: {
    assistantName?: string;
    organizationName?: string;
    organizationBusiness?: string;
  };
}): string {
  const escapedPrompt = params.promptContent
    .replace(/\\/g, "\\\\")
    .replace(/`/g, "\\`")
    .replace(/\$/g, "\\$");

  const assistantName = params.metadata?.assistantName || "Assistant";
  const organizationName = params.metadata?.organizationName || "Organization";
  const organizationBusiness =
    params.metadata?.organizationBusiness || "Business services";

  return `/**
 * Injection File
 *
 * Account: ${params.accountId}
 * Assistant: ${params.assistantId}
 * Version: ${params.version}
 * Generated: ${new Date().toISOString()}
 *
 * DO NOT EDIT - This file is auto-generated by the prompt pipeline.
 * To make changes, update the briefing and regenerate.
 *
 * Usage:
 *   - Use updateMermaidAssistant() to update via MermAId Chat API
 *   - Use sendMessageWithPrompt() to test directly with Anthropic API
 */

// Prompt content (full system prompt)
export const PROMPT_CONTENT = \`${escapedPrompt}\`;

// Metadata
export const METADATA = {
  accountId: "${params.accountId}",
  assistantId: "${params.assistantId}",
  version: "${params.version}",
  generatedAt: "${new Date().toISOString()}",
  contentHash: "${hashContent(params.promptContent)}",
  assistantName: "${assistantName}",
  organizationName: "${organizationName}",
  organizationBusiness: "${organizationBusiness}",
} as const;

/**
 * MermAId API Options format
 * This is the payload structure for updating assistants via MermAId Chat API
 */
export const MERMAID_OPTIONS = {
  assistantName: "${assistantName}",
  organizationName: "${organizationName}",
  organizationBusiness: "${organizationBusiness}",
  promptPrelude: "",
  assistantRole: "Assistente virtual de ${organizationName}",
  assistantPersonality: "Comunicativo, prestativo e focado em ajudar o cliente",
  organizationInfo: [] as string[],
  promptPostlude: PROMPT_CONTENT,
} as const;

/**
 * Update assistant via MermAId Chat API
 *
 * Usage:
 *   import { updateMermaidAssistant, METADATA } from "./injection";
 *   await updateMermaidAssistant(METADATA.assistantId);
 */
export async function updateMermaidAssistant(
  assistantId: string = METADATA.assistantId,
  token?: string
): Promise<{ success: boolean; error?: string }> {
  const mermaidToken = token || process.env.MERMAID_TOKEN;

  if (!mermaidToken) {
    return { success: false, error: "MERMAID_TOKEN not provided" };
  }

  const url = \`https://api.mermaid.chat/api/assistants/\${assistantId}\`;

  try {
    const response = await fetch(url, {
      method: "PATCH",
      headers: {
        "Authorization": \`Bearer \${mermaidToken}\`,
        "Content-Type": "application/json",
      },
      body: JSON.stringify({ options: MERMAID_OPTIONS }),
    });

    if (!response.ok) {
      const errorText = await response.text();
      return { success: false, error: \`API error: \${response.status} - \${errorText}\` };
    }

    console.log("Successfully updated assistant:", assistantId);
    return { success: true };
  } catch (error) {
    const errorMessage = error instanceof Error ? error.message : String(error);
    return { success: false, error: errorMessage };
  }
}

/**
 * Use the prompt in a message (Anthropic direct API)
 */
export async function sendMessageWithPrompt(
  userMessage: string,
  apiKey?: string
): Promise<string> {
  const anthropicKey = apiKey || process.env.ANTHROPIC_API_KEY;

  if (!anthropicKey) {
    throw new Error("ANTHROPIC_API_KEY not provided");
  }

  const response = await fetch("https://api.anthropic.com/v1/messages", {
    method: "POST",
    headers: {
      "x-api-key": anthropicKey,
      "anthropic-version": "2023-06-01",
      "Content-Type": "application/json",
    },
    body: JSON.stringify({
      model: "claude-opus-4-5-20251101",
      max_tokens: 8192,
      system: PROMPT_CONTENT,
      messages: [{ role: "user", content: userMessage }],
    }),
  });

  if (!response.ok) {
    throw new Error(\`Anthropic API error: \${response.status}\`);
  }

  const data = await response.json();
  return data.content
    .filter((block: { type: string }) => block.type === "text")
    .map((block: { text: string }) => block.text)
    .join("\\n");
}

// Default export for easy import
export default {
  PROMPT_CONTENT,
  METADATA,
  MERMAID_OPTIONS,
  updateMermaidAssistant,
  sendMessageWithPrompt,
};
`;
}

/**
 * Save injection file to disk
 */
export function saveInjectionFile(params: {
  accountId: string;
  assistantId: string;
  version: string;
  promptContent: string;
}): InjectionFile {
  const versionPath = generateVersionPath(
    params.accountId,
    params.assistantId,
    params.version,
  );
  const fullPath = join(process.cwd(), versionPath);

  // Ensure directory exists
  if (!existsSync(fullPath)) {
    mkdirSync(fullPath, { recursive: true });
    logger.info("Created version directory", { path: fullPath });
  }

  // Generate and save injection file
  const injectionContent = generateInjectionContent(params);
  const injectionPath = join(
    fullPath,
    generateInjectionFileName(params.version),
  );
  writeFileSync(injectionPath, injectionContent, "utf-8");
  logger.info("Saved injection file", { path: injectionPath });

  // Save prompt markdown
  const promptPath = join(fullPath, generatePromptFileName(params.version));
  writeFileSync(promptPath, params.promptContent, "utf-8");
  logger.info("Saved prompt file", { path: promptPath });

  const injectionFile: InjectionFile = {
    id: generateId("inj"),
    accountId: params.accountId,
    assistantId: params.assistantId,
    version: params.version,
    filePath: injectionPath,
    promptContent: params.promptContent,
    createdAt: new Date().toISOString(),
    status: "ready",
  };

  return injectionFile;
}

/**
 * Generate injection from GeneratedPrompt
 */
export function createInjectionFromPrompt(
  prompt: GeneratedPrompt,
  version: string,
): InjectionFile {
  return saveInjectionFile({
    accountId: prompt.accountId,
    assistantId: prompt.assistantId,
    version,
    promptContent: prompt.content,
  });
}
